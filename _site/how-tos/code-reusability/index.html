<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Swift Tutorial: How Many Ways Are There To Make A Chunk Of Code Reusable — SwiftFoxx</title>

  <meta name="description" content="A comprehensive guide to code reusability in Swift, covering functions, types, protocols, generics, composition, and modular design with real examples.">
  <meta name="keywords" content="">
  <meta name="author" content="SwiftFoxx">
  <meta name="robots" content="index,follow">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Swift Tutorial: How Many Ways Are There To Make A Chunk Of Code Reusable">
  <meta property="og:description" content="A comprehensive guide to code reusability in Swift, covering functions, types, protocols, generics, composition, and modular design with real examples.">
  <meta property="og:url" content="http://localhost:4000/how-tos/code-reusability/">
  <meta property="og:image" content="https://swiftfoxx.github.io/swiftblog-assets/images/posts/og-images/reusable.code.cover.png">

  <link rel="canonical" href="http://localhost:4000/how-tos/code-reusability/">
  <link rel="icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/eachpost.css">
  <link rel="stylesheet" href="/css/codehighlight.css">

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Swift Tutorial: How Many Ways Are There To Make A Chunk Of Code Reusable",
      "description": "A comprehensive guide to code reusability in Swift, covering functions, types, protocols, generics, composition, and modular design with real examples.",
      "author": {
        "@type": "Person",
        "name": "SwiftFoxx"
      },
      "datePublished": "2026-01-09T00:00:00+05:30",
      "dateModified": "2026-01-09T00:00:00+05:30",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/how-tos/code-reusability/"
      }
    }
    </script>

  <script src="/js/nav-scroll.js" defer></script>
  <script src="/js/code-lang-detect.js"></script>
  <script src="/js/image-no-interaction.js"></script>
</head>

<body>
  <nav class="navigation">
    <div class="menu-left">
        <a href="/">swiftfoxx /</a>
    </div>
    <div class="menu-right">
        <a href="">portfolio</a>
        <a href="">contact</a>
        <div class="glass-search">
            <input type="search" placeholder="search…" />
        </div>
    </div>
</nav>
  <div class="main-container">
    <aside class="leading-rail">
    </aside>
    <div class="wrapper">
      <h1 id="how-many-ways-are-there-to-make-a-chunk-of-code-reusable">How Many Ways Are There To Make A Chunk Of Code Reusable</h1>

<p>Jan 09, 2026 <span class="hashtag">swift</span></p>

<p><img src="https://swiftfoxx.github.io/swiftblog-assets/images/posts/Cover%20Images/reusable.code.cover.png" alt="cover image" class="cover-image" /></p>

<p>Reusability is the key for making any app scalable and flexible. Without it, we keep writing the same piece of code over and over in different files. And this repetition results in increased complexity, more difficult to write test cases and more.</p>

<p>While reusable code can be written in almost any manner but few of them actually help and are community standard. This article walks through the major ways code becomes reusable, using real Swift examples and realistic scenarios.</p>

<h2 id="extraction-functions-and-methods">Extraction: Functions and Methods</h2>

<p>The most fundamental form of reuse happens when repeated logic is extracted into a function. This is where nearly all reusable code begins.</p>

<p>Imagine a SwiftUI app where multiple views need to format a date the same way.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">Utility</span> <span class="p">{</span>
<span class="kd">static</span> <span class="kd">func</span> <span class="nf">formattedDate</span><span class="p">(</span><span class="n">_</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">formatter</span> <span class="o">=</span> <span class="kt">DateFormatter</span><span class="p">()</span>
    <span class="n">formatter</span><span class="o">.</span><span class="n">dateStyle</span> <span class="o">=</span> <span class="o">.</span><span class="n">medium</span>
    <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">date</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, any view can format a <code class="language-plaintext inline-code highlighter-rouge">Date</code> object using the function.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">FeedView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="k">left</span><span class="p">,</span> <span class="nv">spacing</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Enjoy your feed today"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">largeTitle</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="kt">Utility</span><span class="o">.</span><span class="nf">formattedDate</span><span class="p">(</span><span class="kt">Date</span><span class="p">()))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In real projects, this technique prevents subtle bugs caused by slightly different implementations of “the same” logic scattered across files. When formatting rules change, you update one place instead of hunting ten.</p>

<p>However, functions stop scaling well once behavior needs configuration or state. That is when reuse moves to the next level.</p>

<h2 id="types-structs-classes-and-enums">Types: Structs, Classes, and Enums</h2>

<p>When reusable logic needs to carry state or represent a concept, it naturally becomes a type.</p>

<p>Consider networking code that talks to an API. A function alone cannot describe retries, headers, or authentication state cleanly.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">APIClient</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">baseURL</span><span class="p">:</span> <span class="kt">URL</span>

    <span class="kd">func</span> <span class="nf">request</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="n">baseURL</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">let</span> <span class="p">(</span><span class="nv">data</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This struct is reusable because it encapsulates both behavior and configuration. Multiple screens can create their own instance, or a single shared instance can be injected.</p>

<p>Enums also enable reuse by centralizing decision logic.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">AppTheme</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">light</span>
    <span class="k">case</span> <span class="n">dark</span>

    <span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">Color</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">light</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">white</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">dark</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">black</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, reuse is not about lines of code but about shared meaning. Every part of the app interprets “theme” the same way.</p>

<h2 id="protocols-and-abstractions">Protocols and Abstractions</h2>

<p>Swift is a language that prefers protocols. A protocol is a set of ‘rules’ that decide how an inheritance works. Protocols allow reuse without sharing concrete implementations. This is where code reuse becomes architectural.</p>

<p><strong>Services</strong> load data but the views don’t need to know where the data comes from. To do it without a protocol would look like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">actor</span> <span class="kt">AccountService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">accountURL</span><span class="p">)</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">actor</span> <span class="kt">ExploreService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">load</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">exploreURL</span><span class="p">)</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At a glance, these types are doing the same job. They both load remote data asynchronously. But structurally, they have nothing in common. The method names differ, the types are unrelated, and there is no shared contract describing their role.</p>

<p>That leak shows up immediately in the view layer.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SettingsView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">text</span> <span class="o">=</span> <span class="s">"Loading"</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="o">.</span><span class="n">task</span> <span class="p">{</span>
                <span class="k">let</span> <span class="nv">accountData</span> <span class="o">=</span> <span class="k">await</span> <span class="kt">AccountService</span><span class="p">()</span><span class="o">.</span><span class="nf">loadData</span><span class="p">()</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s">"Loaded Data"</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The view now knows which service to construct and which method to call. If the service changes, the view changes. If you want to reuse this view with a different data source, you duplicate it or add branching logic. Reuse becomes accidental and brittle.</p>

<p>However, introducing a protocol fixes this by formalizing the shared behavior.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">DataLoadingService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now both services can conform to the same rule set.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">actor</span> <span class="kt">AccountService</span><span class="p">:</span> <span class="kt">DataLoadingService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">accountURL</span><span class="p">)</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">actor</span> <span class="kt">ExploreService</span><span class="p">:</span> <span class="kt">DataLoadingService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">exploreURL</span><span class="p">)</span><span class="o">.</span><span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Nothing about the concrete implementations is shared, and that’s the point. What’s shared is the expectation.</p>

<p>The view can now depend on behavior instead of a concrete type.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SettingsView</span><span class="o">&lt;</span><span class="kt">Service</span><span class="p">:</span> <span class="kt">DataLoadingService</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">service</span><span class="p">:</span> <span class="kt">Service</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">text</span> <span class="o">=</span> <span class="s">"Loading"</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="o">.</span><span class="n">task</span> <span class="p">{</span>
                <span class="n">_</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="k">await</span> <span class="n">service</span><span class="o">.</span><span class="nf">loadData</span><span class="p">()</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s">"Loaded Data"</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>At this point, reuse becomes deliberate. The view is reusable with any service that conforms to <code class="language-plaintext inline-code highlighter-rouge">DataLoadingService</code>. Testing becomes a breeze. Swapping implementations stops being a refactor and starts being configuration.</p>

<p>Without protocols, code reuse relies on copy-paste discipline and naming conventions. With protocols, reuse is enforced by the compiler. That difference is not stylistic. It is structural, and over time, it is the difference between a codebase that scales and one that resists change.</p>

<h2 id="extensions">Extensions</h2>

<p>Extensions allow reuse without ownership. They are ideal when you want to add shared behavior to types you do not control or when functionality conceptually belongs to an existing type.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">isValidEmail</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">contains</span><span class="p">(</span><span class="s">"."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code becomes reusable everywhere strings are used, without creating helper objects or utility files.</p>

<p>In real apps, extensions often serve as glue. They let you keep models clean while still sharing logic across features.</p>

<p>The danger is overuse. Too many extensions can scatter behavior across files, making it hard to discover where functionality lives.</p>

<h2 id="composition">Composition</h2>

<p>Composition reuses behavior by assembling smaller reusable parts rather than inheriting from a shared base.</p>

<p>In SwiftUI, this happens constantly.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">PrimaryButton</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">action</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Button</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="n">action</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">white</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">cornerRadius</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This view is reused across screens, but it is also composed of reusable SwiftUI primitives.</p>

<p>Composition scales better than inheritance because it avoids rigid hierarchies. You can replace parts without breaking consumers.</p>

<p>This pattern is also common outside UI. A service composed of smaller helpers is easier to reuse than one massive object that does everything.</p>

<h2 id="generics">Generics</h2>

<p>Generics allow reuse across types while preserving type safety.</p>

<p>Consider caching values.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Cache</span><span class="o">&lt;</span><span class="kt">Key</span><span class="p">:</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="kt">Value</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="p">[</span><span class="kt">Key</span><span class="p">:</span> <span class="kt">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">insert</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span><span class="p">,</span> <span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">value</span><span class="p">(</span><span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Value</span><span class="p">?</span> <span class="p">{</span>
        <span class="n">storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This cache works for images, API responses, view models, or anything else. The behavior is reused without knowing the concrete types ahead of time.</p>

<p>Generics shine when behavior is identical but data types vary. They reduce duplication without sacrificing clarity.</p>

<h2 id="modules-and-packages">Modules and Packages</h2>

<p>At a higher level, reuse crosses project boundaries.</p>

<p>A Swift Package might contain logging, analytics, or design system components shared across multiple apps.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">MyDesignSystem</span>

<span class="kt">PrimaryButton</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Continue"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">submit</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, reuse is intentional, versioned, and documented. Changes must consider downstream users.</p>

<p>This level of reuse introduces cost. APIs must remain stable, and abstractions must be carefully designed. It is worth it only when code truly belongs to more than one product.</p>

<h2 id="patterns-and-conventions">Patterns and Conventions</h2>

<p>Not all reuse is literal code reuse. Sometimes what gets reused is structure.</p>

<p>When every feature follows the same folder layout, naming conventions, and data flow, developers mentally reuse knowledge instead of copying code.</p>

<p>For example, if every screen has a View, ViewModel, and State, adding a new screen is faster even if no files are shared.</p>

<p>This kind of reuse reduces cognitive load. It matters as much as technical reuse in large teams.</p>

<hr />

<h2 class="empty1" id="choosing-the-right-level-of-reuse">Choosing the Right Level of Reuse</h2>

<p>Not every repeated line deserves abstraction. Premature reuse often creates more complexity than it saves. A good rule is that reuse should emerge from repetition, not anticipation. When code appears twice, notice it, when it appears three times, extract it, when it appears across features, abstract it, and when it appears across apps, package it.</p>

<p>Each reuse technique exists because it solves a different problem. Functions reduce duplication, Types model concepts, Protocols enable change, Composition scales, Modules cross boundaries.</p>

<p>The skill is not knowing all the ways to reuse code. It is knowing when to stop.</p>

    </div>
    <aside class="trailing-rail">
      <p><b>Published</b></p>
      <p> Jan 09, 2026</p>
      
      
    </aside>
  </div>
</body>

</html>